<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (11.0.2) on Sat Feb 20 17:17:05 CET 2021 -->
<title>CharacterSearchTree</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="dc.created" content="2021-02-20">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CharacterSearchTree";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<h2 title="Class CharacterSearchTree" class="title">Class CharacterSearchTree</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>CharacterSearchTree</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">CharacterSearchTree</span>
extends java.lang.Object</pre>
<div class="block"><img src="https://www.uni-due.de/imperia/md/images/jcs-ruhr/logo_tudortmund.png" width="15%" height="auto">
 <center>
  <h1>Autor</h1>
  <p>
      Dokumentiert von: <em>Mert Can &Ouml;zdemir</em><br/>
      Modul: <em>DAP1</em>
  </p>
  <h2>Dokumentation der Klasse CharacterSearchTree</h2>
  <p>
      - Die Klasse 'CharacterSearchTree hat viele Gemeinsamkeiten mit der Klasse 'HuffmanTree': Beide Klassen dienen dem Aufbau bin&auml;rer B&auml;ume<br/>
      - Die Klassen enthalten Attribute f&uuml;r die gleichen Aufgaben: 'leftChild' und 'rightChild' f&uuml;r die Konstruktion des Baums, 'content' f&uuml;r den Inhalt eines Knotens<br/>
      - Die Konstruktionsregeln des bin&auml;ren Suchbaums dr&uuml;cken sich nicht in seinen Atrributen aus. Die Konstruktionsregeln werden von Methoden sichergestellt, die einen Baum erzeugen und diesen verwalten.<br/>
          -> Der 'CharacterSearchTree' wird ganz anders aufgebaut als der 'HuffmanTree'<br/>
              => Der 'CharacterSearchTree' wird &uuml;ber Methoden aufgebaut, w&auml;hrend der 'HuffmanTree' &uuml;ber seine Konstruktoren aufgebaut wird.
  </p>
 </center></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">CharacterSearchTree</a></span>()</code></th>
<td class="colLast">
<div class="block">Konstruktor - CharacterSearchTree()</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(char)">add</a></span>&#8203;(char&nbsp;t)</code></th>
<td class="colLast">
<div class="block">void add( char t )</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCode(char)">getCode</a></span>&#8203;(char&nbsp;t)</code></th>
<td class="colLast">
<div class="block">String getCode( char t )</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>HuffmanTriple</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContent()">getContent</a></span>()</code></th>
<td class="colLast">
<div class="block">HuffmanTriple getContent()</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEmpty()">isEmpty</a></span>()</code></th>
<td class="colLast">
<div class="block">boolean isEmpty()</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLeaf()">isLeaf</a></span>()</code></th>
<td class="colLast">
<div class="block">boolean isLeaf()</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterativeAdd(char)">iterativeAdd</a></span>&#8203;(char&nbsp;t)</code></th>
<td class="colLast">
<div class="block">void iterativeAdd( char t )</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#show()">show</a></span>()</code></th>
<td class="colLast">
<div class="block">void show()</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#size()">size</a></span>()</code></th>
<td class="colLast">
<div class="block">int size()</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>HuffmanTriple[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toArray()">toArray</a></span>()</code></th>
<td class="colLast">
<div class="block">HuffmanTriple[] toArray()</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CharacterSearchTree</h4>
<pre>public&nbsp;CharacterSearchTree()</pre>
<div class="block"><h1>Konstruktor - CharacterSearchTree()</h1>
 <p>
  Der Konstruktor ohne Parameter, legt einen leeren Baum an
 </p></div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="getContent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContent</h4>
<pre class="methodSignature">public&nbsp;HuffmanTriple&nbsp;getContent()</pre>
<div class="block"><h1>HuffmanTriple getContent()</h1>
 <p>
  getContent liefert den Inhalt des aktuellen Knotens, wenn dieser nicht leer ist.<br/>
  Wird versucht auf einen leeren Knoten zuzugreifen, dann wird eine Ausnahme geworfen.
 </p></div>
</li>
</ul>
<a id="isEmpty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEmpty</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isEmpty()</pre>
<div class="block"><h1>boolean isEmpty()</h1>
 <p>
  isEmpty() gibt true zurück, wenn der aktuelle Knoten leer ist.<br/>
  ist er nicht leer, wird false zurück gegeben.
 </p></div>
</li>
</ul>
<a id="isLeaf()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeaf</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isLeaf()</pre>
<div class="block"><h1>boolean isLeaf()</h1>
 <p>
  Wenn der aktuelle Knoten ein Blatt ist, also nicht leer ist und sein linker & rechter Teilbaum leer sind,<br/>
  wird true zurückgegeben.<br/>
  Sonst wird false zurückgegeben.
 </p></div>
</li>
</ul>
<a id="add(char)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;add&#8203;(char&nbsp;t)</pre>
<div class="block"><h1>void add( char t )</h1>
 <h2>Das Einf&uuml;gen eines Zeichens in den Baum erfordert</h2>
 <p>
  - entweder das Anlegen eines neuen Knotens f&uuml;r dieses Zeichen<br/>
  - oder das Erh&ouml;hen der H&auml;ufigkeit f&uuml;r das schon vorhandene Zeichen:
 </p></div>
</li>
</ul>
<a id="iterativeAdd(char)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterativeAdd</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;iterativeAdd&#8203;(char&nbsp;t)</pre>
<div class="block"><h1>void iterativeAdd( char t )</h1>
 <p>
  Da die Methode 'add()' immer einem bestimmten, durch die Ergebnisse der Vergleiche vorgegebenen Pfad von Knoten durch einen Teilbaum folgt, kann sie auch iterativ, also durch die Nutzung einer Schleife formuliert werden.
 </p></div>
</li>
</ul>
<a id="getCode(char)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCode</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getCode&#8203;(char&nbsp;t)</pre>
<div class="block"><h1>String getCode( char t )</h1>
 <p>
  Sucht nach dem Zeichen im 
 </p></div>
</li>
</ul>
<a id="size()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>size</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;size()</pre>
<div class="block"><h1>int size()</h1>
 <p>
  Z&auml;hlt die Anzahl der unterschiedlichen Zeichen ('token's), der 'HuffmanTripple'-Objekte, die sich als 'content' in unserem Baum befinden<br/>
      -> Das Feststellen der Anzahl der abgelegten, unterschiedlichen Zeichen l&auml;sst sich ebenfalls an die nachfolgenden Teilb&auml;ume &uuml;bertragen und daher rekursiv formulieren:<br/>
          => Jeder nicht-leere Teilbaum besteht aus der Anzahl der Zeichen, die in den Teilbäumen Abgelegt sind (<span style="color:red;">leftChild.size() + rightChild.size()</span>)<br/>
          => und aus dem einen Zeichen in seiner Wurzel (<span style="color:red">+1</span>)
 </p></div>
</li>
</ul>
<a id="show()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>show</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;show()</pre>
<div class="block"><h1>void show()</h1>
 <p>
  Die Ausfgabe der abgelegten, unterschiedlichen Zeicheen und ihrer H&auml;ufigkeiten l&auml;sst sich ebenfalls an die nachfolgenden Teilb&auml;ume &uuml;bertragen und daher rekursiv formulieren
 </p>
 <p>
  Gibt den Baum in einem in-order Tiefendurchlauf aus. (-> InOrder-Durchlauf: Die Wurzel wird zwischen (, also in) den beiden Teilb&auml;umen bearbeitet)<br/>
  <!--Notiz (Fr, 08.01.2021) (Quelle: Folie: 893)-->Da der Tiefendurchlauf in-Order statfindet, ist die Liste anschließend aufsteigend sortiert.
 </p></div>
</li>
</ul>
<a id="toArray()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toArray</h4>
<pre class="methodSignature">public&nbsp;HuffmanTriple[]&nbsp;toArray()</pre>
<div class="block"><h1>HuffmanTriple[] toArray()</h1>
 <p>
  - Die &Uuml;bergabe der abgelegten, unterschiedlichen Zeichen und ihrer H&auml;ufigkeiten an ein Feld wird als Eingabe für Klasse 'HuffmanCoding' ben&ouml;tigt.<br/>
  - Das Erzeugen eines solchen Feldes lässt sich ebenfalls &uuml;ber einen InOrder-Durchlauf rekursiv formulieren. <br/>
  - Die Methode 'toArray()' bereitet den InOrder-Durchlauf vor, indem ein passendes Feld für 'HuffmanTriple'-Objekte bereitgestellt wird.<br/>
  - Die Anzahl der benötigten Elemente wird durch den Aufruf der Methode 'size()' ermittelt.
 </p>
 <h2>Wie k&ouml;nnen wir den CharacterSearchTree benutzen, um die Eingaben für unseren Huffman Algorithmus zu schaffen?</h2>
 <p>
  -> Wir möchten ein Feld von 'HuffmanTriple'-Objekten haben<br/>
  -> Der Inhalt unserer Knoten sind 'HuffmanTriple'-Objekte <br/>
  => Wir müssen unsere Knoten in ein Feld ablegen.
 </p></div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
